# -*- coding: utf-8 -*-
"""IRIS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DUUfKvF-tR1kU6BIU3MQN_96zTfN7R2Y
"""

#import libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#import dataset
IRIS_dataset = pd.read_csv('/content/IRIS.csv')

IRIS_dataset.head()

IRIS_dataset.describe()

IRIS_dataset.info()

IRIS_dataset.isnull().sum()

import seaborn as sns
sns.pairplot(IRIS_dataset, hue="species", markers=["o", "s", "D"])
plt.show()

# Count the occurrences of each species
species_counts = IRIS_dataset['species'].value_counts()

# Plot the bar chart
plt.figure(figsize=(8, 6))
sns.barplot(x=species_counts.index, y=species_counts.values, color='skyblue')
plt.xlabel('Species')
plt.ylabel('Count')
plt.title('Count of Each Species in Iris Dataset')
plt.show()

X = IRIS_dataset.iloc[:, :-1].values
y = IRIS_dataset.iloc[:, -1].values
print('Matrix of Features: ', X )
print('Dependent Variable: ', y)

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
y = le.fit_transform(y)
print('Encoded Categorical dependent variable vector: ', y)

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size= 0.3, random_state = 1)
print('x_train: ', X_train)
print('x_test: ', X_test)
print('y_train: ', y_train)
print('y_test: ', y_test)

#Feature Scaling
#standardisation:
from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)
print('Featured Scaled x-train:\n ',X_train)
print('Featured Scaled x-test:\n ',X_test)

from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score

classifiers = {
    "Random Forest Classifier": RandomForestClassifier(n_estimators=100, random_state=42),
    "K-Nearest Neighbors Classifier": KNeighborsClassifier(n_neighbors=5),
    "Support Vector Machine Classifier": SVC(kernel='rbf', random_state=42)
}

accuracies = []

for name, classifier in classifiers.items():
    classifier.fit(X_train, y_train)
    y_pred = classifier.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    accuracies.append(accuracy)
    print(f"{name} Accuracy: {accuracy}")

fig, ax = plt.subplots()
models = classifiers.keys()
y_pos = np.arange(len(models))
ax.barh(y_pos, accuracies, align='center')
ax.set_yticks(y_pos)
ax.set_yticklabels(models)
ax.invert_yaxis()
ax.set_xlabel('Accuracy')
ax.set_title('Classifier Accuracies')
plt.show()

best_accuracy = max(accuracies)
best_model = list(classifiers.keys())[accuracies.index(best_accuracy)]
print(f"\nBest Model: {best_model} with Accuracy: {best_accuracy}")

# train the model on the best Model
from sklearn.ensemble import RandomForestClassifier
classifier = RandomForestClassifier(n_estimators=100, random_state=42)
classifier.fit(X_train, y_train)

# predict on the test set
y_pred = classifier.predict(X_test)

from sklearn.metrics import accuracy_score, confusion_matrix, precision_score, recall_score, f1_score
# Compute accuracy
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

# Compute confusion matrix
conf_matrix = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:\n", conf_matrix)

# Compute precision
precision = precision_score(y_test, y_pred, average='weighted')
print("Precision:", precision)

# Compute recall
recall = recall_score(y_test, y_pred, average='weighted')
print("Recall:", recall)

# Compute F1 score
f1 = f1_score(y_test, y_pred, average='weighted')
print("F1 Score:", f1)

from sklearn.metrics import classification_report

# Generate classification report
class_report = classification_report(y_test, y_pred)
print("Classification Report:\n", class_report)

# make a prediction
input_data = np.array([5.1, 3.5, 1.4, 0.2]).reshape(1, -1)
input_data_scaled = sc.transform(input_data)
# Make predictions using the reshaped data
predicted_value = classifier.predict(input_data_scaled)

# Print the predicted value
print(predicted_value)